"use strict";(self.webpackChunktik_wiki=self.webpackChunktik_wiki||[]).push([[6259],{3700:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"microservice/mpc/AEAD-for-MPC-over-NATS","title":"AEAD-for-MPC-over-NATS","description":"Below is a pragmatic pattern for application\u2011level AEAD for an MPC system over NATS:","source":"@site/docs/microservice/mpc/AEAD-for-MPC-over-NATS.md","sourceDirName":"microservice/mpc","slug":"/microservice/mpc/AEAD-for-MPC-over-NATS","permalink":"/docs/microservice/mpc/AEAD-for-MPC-over-NATS","draft":false,"unlisted":false,"editUrl":"https://github.com/TikTzuki/tiktzuki.github.io/tree/master/docs/microservice/mpc/AEAD-for-MPC-over-NATS.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docSidebar","previous":{"title":"MPC-based Crypto-Custody Design (Rust) \u2014 SSD","permalink":"/docs/microservice/mpc/MPC-Rust"},"next":{"title":"Networking and DevOps","permalink":"/docs/networking-devops"}}');var r=s(4848),t=s(8453);const a={sidebar_position:2},l=void 0,o={},c=[];function d(e){const n={code:"code",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Below is a pragmatic pattern for application\u2011level AEAD for an MPC system over NATS:"}),"\n",(0,r.jsx)(n.p,{children:"Core goals:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pairwise (or group) secure channels layered above NATS subjects"}),"\n",(0,r.jsx)(n.li,{children:"Forward secrecy via ephemeral X25519 ECDH + HKDF"}),"\n",(0,r.jsx)(n.li,{children:"Explicit AAD binding (session id, round, party ids, algorithm)"}),"\n",(0,r.jsx)(n.li,{children:"Framed messages (version, cipher, session id, counter, lengths)"}),"\n",(0,r.jsx)(n.li,{children:"Replay protection (monotonic counter store)"}),"\n",(0,r.jsx)(n.li,{children:"Periodic rekey / key rotation"}),"\n",(0,r.jsx)(n.li,{children:"Separation of signing (authN) and AEAD (conf+auth)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Design outline:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Identity keys: Long\u2011term Ed25519 (sign) + ephemeral X25519 (KEX)."}),"\n",(0,r.jsx)(n.li,{children:"Handshake:"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each party publishes its ephemeral public key on a control subject."}),"\n",(0,r.jsx)(n.li,{children:"After all are collected, derive a master_secret (e.g. concat sorted shared secrets; or pairwise for scalability)."}),"\n",(0,r.jsx)(n.li,{children:"HKDF(master_secret, info=sorted_party_ids||protocol_label) \u2192 base key material."}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"Session keys:"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'For pairwise: derive per (A,B) sub-key using HKDF with info = "PAIR"+"A|B".'}),"\n",(0,r.jsx)(n.li,{children:'For group broadcast: derive group key with info = "GROUP".'}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsxs)(n.li,{children:["AEAD session object (like existing ",(0,r.jsx)(n.code,{children:"AeadSession"}),") manages:"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"session_id (random 4 bytes)"}),"\n",(0,r.jsx)(n.li,{children:"atomic counter (nonce suffix)"}),"\n",(0,r.jsx)(n.li,{children:"key bytes"}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"5",children:["\n",(0,r.jsx)(n.li,{children:"AAD content example: version || session_id || round || sender_party_id || algorithm_tag"}),"\n",(0,r.jsx)(n.li,{children:"Replay:"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep highest counter seen per (session_id, sender). Reject lower or duplicate."}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"7",children:["\n",(0,r.jsx)(n.li,{children:"Rotation:"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Trigger after N messages or time T or near counter wrap. Perform fresh ephemeral ECDH and rebuild sessions."}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"8",children:["\n",(0,r.jsx)(n.li,{children:"NATS subjects:"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Control / handshake: mpc.ctrl.<session_uuid>"}),"\n",(0,r.jsx)(n.li,{children:"Pairwise encrypted: mpc.sec.pair.<A>.<B>"}),"\n",(0,r.jsx)(n.li,{children:"Group broadcast: mpc.sec.group.<group_id>"}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"9",children:["\n",(0,r.jsx)(n.li,{children:"Signing:"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sign the plaintext metadata header (or handshake payload) with Ed25519 to authenticate before AEAD encryption for defense in depth."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Code sketch (simplified) showing: handshake aggregation, session derivation, send/receive with AEAD wrapper. Omitted: error handling details, persistence, batching."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use std::{collections::HashMap, sync::{Arc, RwLock}};\nuse anyhow::Result;\nuse rand::RngCore;\nuse hkdf::Hkdf;\nuse sha2::Sha256;\nuse x25519_dalek::{PublicKey as XPublic, StaticSecret as XSecret};\nuse ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};\nuse async_nats::{Client, Message};\nuse zeroize::Zeroize;\n\nconst AAD_VERSION: u8 = 1;\nconst CIPHER_CHACHA20: u8 = 1;\n\n#[derive(Clone)]\npub struct PartyId(pub String);\n\npub struct HandshakeBundle {\n    pub party_id: PartyId,\n    pub eph_pub: [u8; 32],\n    pub sig: Signature,\n}\n\npub struct CryptoIdentity {\n    sign_sk: SigningKey,\n    sign_vk: VerifyingKey,\n    x_secret: XSecret,\n    x_public: XPublic,\n}\n\nimpl CryptoIdentity {\n    pub fn new(sign_sk: SigningKey) -> Self {\n        let sign_vk = sign_sk.verifying_key();\n        let x_secret = XSecret::new(rand::rngs::OsRng);\n        let x_public = XPublic::from(&x_secret);\n        Self { sign_sk, sign_vk, x_secret, x_public }\n    }\n    pub fn handshake_advert(&self, me: &PartyId) -> HandshakeBundle {\n        let mut msg = Vec::new();\n        msg.extend_from_slice(me.0.as_bytes());\n        msg.extend_from_slice(self.x_public.as_bytes());\n        let sig = self.sign_sk.sign(&msg);\n        HandshakeBundle { party_id: me.clone(), eph_pub: *self.x_public.as_bytes(), sig }\n    }\n}\n\npub struct AeadSession {\n    cipher: u8,\n    session_id: [u8;4],\n    counter: u64,\n    key: Vec<u8>,\n}\n\nimpl Drop for AeadSession {\n    fn drop(&mut self) { self.key.zeroize(); }\n}\n\nimpl AeadSession {\n    pub fn new(cipher: u8, key: Vec<u8>) -> Self {\n        let mut sid = [0u8;4];\n        rand::rngs::OsRng.fill_bytes(&mut sid);\n        Self { cipher, session_id: sid, counter: 0, key }\n    }\n    fn next_counter(&mut self) -> u64 {\n        let c = self.counter;\n        self.counter += 1;\n        c\n    }\n    fn nonce(&self, counter: u64) -> [u8;12] {\n        let mut n=[0u8;12];\n        n[..4].copy_from_slice(&self.session_id);\n        n[4..].copy_from_slice(&counter.to_be_bytes());\n        n\n    }\n    pub fn encrypt(&mut self, plaintext: &[u8], aad_ctx: &[u8]) -> Result<Vec<u8>> {\n        let cnt = self.next_counter();\n        let nonce = self.nonce(cnt);\n        // Using chacha20poly1305\n        use chacha20poly1305::{ChaCha20Poly1305, aead::{Aead, KeyInit}, Key, Nonce};\n        let key = Key::from_slice(&self.key);\n        let aead = ChaCha20Poly1305::new(key);\n        let ct = aead.encrypt(Nonce::from_slice(&nonce), chacha20poly1305::aead::Payload {\n            msg: plaintext,\n            aad: aad_ctx\n        })?;\n        // Frame: [ver][cipher][sid4][counter8][aad_len2][ct_len4][aad][ct]\n        let mut out = Vec::with_capacity(1+1+4+8+2+4+aad_ctx.len()+ct.len());\n        out.push(AAD_VERSION);\n        out.push(self.cipher);\n        out.extend_from_slice(&self.session_id);\n        out.extend_from_slice(&cnt.to_be_bytes());\n        out.extend_from_slice(&(aad_ctx.len() as u16).to_be_bytes());\n        out.extend_from_slice(&(ct.len() as u32).to_be_bytes());\n        out.extend_from_slice(aad_ctx);\n        out.extend_from_slice(&ct);\n        Ok(out)\n    }\n    pub fn decrypt(&self, frame: &[u8], expected_aad_prefix: &[u8]) -> Result<(Vec<u8>, u64)> {\n        if frame.len() < 1+1+4+8+2+4 { anyhow::bail!("short"); }\n        let mut i=0;\n        if frame[i] != AAD_VERSION { anyhow::bail!("ver"); } i+=1;\n        if frame[i] != self.cipher { anyhow::bail!("cipher"); } i+=1;\n        if &frame[i..i+4] != &self.session_id { anyhow::bail!("sid"); } i+=4;\n        let counter = u64::from_be_bytes(frame[i..i+8].try_into()?); i+=8;\n        let aad_len = u16::from_be_bytes(frame[i..i+2].try_into()? ) as usize; i+=2;\n        let ct_len = u32::from_be_bytes(frame[i..i+4].try_into()? ) as usize; i+=4;\n        if frame.len() < i+aad_len+ct_len { anyhow::bail!("trunc"); }\n        let aad = &frame[i..i+aad_len]; i+=aad_len;\n        let ct = &frame[i..i+ct_len];\n        if !aad.starts_with(expected_aad_prefix) { anyhow::bail!("aad mismatch"); }\n        let nonce = self.nonce(counter);\n        use chacha20poly1305::{ChaCha20Poly1305, aead::{Aead, KeyInit}, Key, Nonce};\n        let key = Key::from_slice(&self.key);\n        let aead = ChaCha20Poly1305::new(key);\n        let pt = aead.decrypt(Nonce::from_slice(&nonce), chacha20poly1305::aead::Payload {\n            msg: ct,\n            aad\n        })?;\n        Ok((pt, counter))\n    }\n}\n\npub struct SessionStore {\n    // key: channel id (pairwise or group)\n    map: RwLock<HashMap<String, AeadSession>>,\n    highest: RwLock<HashMap<String, u64>>, // replay tracking\n}\n\nimpl SessionStore {\n    pub fn new() -> Self {\n        Self {\n            map: RwLock::new(HashMap::new()),\n            highest: RwLock::new(HashMap::new()),\n        }\n    }\n    pub fn insert(&self, chan: String, sess: AeadSession) {\n        self.map.write().unwrap().insert(chan, sess);\n    }\n    pub fn encrypt(&self, chan: &str, aad: &[u8], pt: &[u8]) -> Result<Vec<u8>> {\n        let mut guard = self.map.write().unwrap();\n        let sess = guard.get_mut(chan).ok_or_else(|| anyhow::anyhow!("no session"))?;\n        sess.encrypt(pt, aad)\n    }\n    pub fn decrypt(&self, chan: &str, frame: &[u8], expect_aad_prefix: &[u8]) -> Result<Vec<u8>> {\n        let guard = self.map.read().unwrap();\n        let sess = guard.get(chan).ok_or_else(|| anyhow::anyhow!("no session"))?;\n        let (pt, counter) = sess.decrypt(frame, expect_aad_prefix)?;\n        let mut h = self.highest.write().unwrap();\n        let hi = h.entry(chan.to_string()).or_insert(0);\n        if counter < *hi { anyhow::bail!("replay"); }\n        if counter == *hi { anyhow::bail!("dup"); }\n        *hi = counter;\n        Ok(pt)\n    }\n}\n\n// Derive a base key from collected handshakes (group mode)\npub fn derive_group_key(bundles: &[HandshakeBundle]) -> Result<Vec<u8>> {\n    // For simplicity: concatenate sorted pub keys; in production use pairwise shared secrets & KDF tree\n    let mut pubs: Vec<&[u8]> = bundles.iter().map(|b| &b.eph_pub[..]).collect();\n    pubs.sort();\n    let mut material = Vec::new();\n    for p in pubs { material.extend_from_slice(p); }\n    let hk = Hkdf::<Sha256>::new(None, &material);\n    let mut okm = vec![0u8; 32];\n    hk.expand(b"mpc-group-key-v1", &mut okm).map_err(|_| anyhow::anyhow!("hkdf fail"))?;\n    Ok(okm)\n}\n\n// Example send (pairwise)\npub async fn send_pairwise(nc: &Client, store: Arc<SessionStore>, a: &PartyId, b: &PartyId, round: u32, payload: &[u8]) -> Result<()> {\n    let chan = format!("pair:{}:{}", a.0, b.0);\n    let aad = build_aad(a, round);\n    let frame = store.encrypt(&chan, &aad, payload)?;\n    let subj = format!("mpc.sec.pair.{}.{}", a.0, b.0);\n    nc.publish(subj, frame.into()).await?;\n    Ok(())\n}\n\nfn build_aad(sender: &PartyId, round: u32) -> Vec<u8> {\n    let mut v = Vec::with_capacity(1 + sender.0.len() + 4);\n    v.push(0x01); // AAD schema version\n    v.extend_from_slice(sender.0.as_bytes());\n    v.extend_from_slice(&round.to_be_bytes());\n    v\n}\n\npub async fn recv_pairwise(store: Arc<SessionStore>, a: &PartyId, b: &PartyId, msg: &Message) -> Result<Vec<u8>> {\n    let chan = format!("pair:{}:{}", a.0, b.0);\n    let prefix = [0x01u8]; // expect AAD version prefix\n    store.decrypt(&chan, &msg.payload, &prefix)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Key rotation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Re-run ephemeral X25519 exchange"}),"\n",(0,r.jsx)(n.li,{children:"Derive fresh keys"}),"\n",(0,r.jsxs)(n.li,{children:["Call ",(0,r.jsx)(n.code,{children:"AeadSession::new"})," and replace in ",(0,r.jsx)(n.code,{children:"SessionStore"})]}),"\n",(0,r.jsx)(n.li,{children:"Invalidate old session after grace window"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Hardening suggestions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use constant-time compares (",(0,r.jsx)(n.code,{children:"subtle"}),") for IDs"]}),"\n",(0,r.jsx)(n.li,{children:"Limit frame size and enforce max"}),"\n",(0,r.jsx)(n.li,{children:"Add timestamp / round window checks"}),"\n",(0,r.jsx)(n.li,{children:"Consider per-message ephemeral key (heavier) if stronger Forward Secrecy required"}),"\n",(0,r.jsx)(n.li,{children:"Add optional post-quantum KEM hybrid later"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This pattern layers cleanly over NATS without modifying transport while providing deterministic nonce construction and replay defense."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);