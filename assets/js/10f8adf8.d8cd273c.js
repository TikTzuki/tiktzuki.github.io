"use strict";(self.webpackChunktik_wiki=self.webpackChunktik_wiki||[]).push([[5755],{8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var r=n(6540);const t={},i=r.createContext(t);function o(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:s},e.children)}},9015:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"microservice/mpc/MPC-Rust","title":"MPC-based Crypto-Custody Design (Rust) \u2014 SSD","description":"Terms","source":"@site/docs/microservice/mpc/MPC-Rust.md","sourceDirName":"microservice/mpc","slug":"/microservice/mpc/MPC-Rust","permalink":"/docs/microservice/mpc/MPC-Rust","draft":false,"unlisted":false,"editUrl":"https://github.com/TikTzuki/tiktzuki.github.io/tree/master/docs/microservice/mpc/MPC-Rust.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docSidebar","previous":{"title":"\ud83d\ude80 What is Raft Consensus?","permalink":"/docs/microservice/connsensus/raft"},"next":{"title":"AEAD-for-MPC-over-NATS","permalink":"/docs/microservice/mpc/AEAD-for-MPC-over-NATS"}}');var t=n(4848),i=n(8453);const o={sidebar_position:1},c="MPC-based Crypto-Custody Design (Rust) \u2014 SSD",l={},a=[{value:"Terms",id:"terms",level:2},{value:"Protocols",id:"protocols",level:3},{value:"Round-based protocol",id:"round-based-protocol",level:4},{value:"GG18",id:"gg18",level:4},{value:"GG20",id:"gg20",level:4},{value:"CGGMP24",id:"cggmp24",level:4},{value:"Scopes",id:"scopes",level:2},{value:"MPC - SSD",id:"mpc---ssd",level:2},{value:"1. Protocol choice &amp; justification",id:"1-protocol-choice--justification",level:3},{value:"2. High-level architecture",id:"2-high-level-architecture",level:3},{value:"3. Rust ecosystem and crates (recommended)",id:"3-rust-ecosystem-and-crates-recommended",level:3},{value:"4. Detailed module layout (Rust workspace)",id:"4-detailed-module-layout-rust-workspace",level:3},{value:"Core responsibilities",id:"core-responsibilities",level:4},{value:"5. Messaging &amp; session flow (NATS)",id:"5-messaging--session-flow-nats",level:3},{value:"6. Key generation (MPC KeyGen) flow (concrete)",id:"6-key-generation-mpc-keygen-flow-concrete",level:3},{value:"7. Signing (MPC Sign) flow (concrete)",id:"7-signing-mpc-sign-flow-concrete",level:3},{value:"8. Storage, HSM &amp; secure share handling",id:"8-storage-hsm--secure-share-handling",level:3},{value:"9. Access Control, Authentication &amp; Audit",id:"9-access-control-authentication--audit",level:3},{value:"10. Recovery &amp; Rotation",id:"10-recovery--rotation",level:3},{value:"11. Transaction policy examples",id:"11-transaction-policy-examples",level:3},{value:"12. Testing, audits &amp; hardening",id:"12-testing-audits--hardening",level:3},{value:"13. Example code snippets",id:"13-example-code-snippets",level:3},{value:"14. Security trade-offs &amp; practical notes",id:"14-security-trade-offs--practical-notes",level:3},{value:"15. Deployment checklist",id:"15-deployment-checklist",level:3},{value:"16. Next steps (practical implementation plan \u2014 6 milestones)",id:"16-next-steps-practical-implementation-plan--6-milestones",level:3},{value:"17. Useful references &amp; starting points",id:"17-useful-references--starting-points",level:3},{value:"MPC over NATS architecture",id:"mpc-over-nats-architecture",level:2},{value:"Key Share Storage Best Practices",id:"key-share-storage-best-practices",level:2}];function d(e){const s={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"mpc-based-crypto-custody-design-rust--ssd",children:"MPC-based Crypto-Custody Design (Rust) \u2014 SSD"})}),"\n",(0,t.jsx)(s.h2,{id:"terms",children:"Terms"}),"\n",(0,t.jsx)(s.h3,{id:"protocols",children:"Protocols"}),"\n",(0,t.jsx)(s.h4,{id:"round-based-protocol",children:"Round-based protocol"}),"\n",(0,t.jsxs)(s.p,{children:["In round-based protocol we have n parties that can send messages to and receive messages from other parties within rounds (number of parties n is known prior to starting protocol).",(0,t.jsx)(s.br,{}),"\n","At every round party may send a P2P or broadcast message, and it receives all broadcast messages sent by other parties and P2P messages sent directly to it.\nAfter party's received enough round messages in this round, it either proceeds (evaluates something on received messages and goes to next round) or finishes the protocol."]}),"\n",(0,t.jsx)(s.h4,{id:"gg18",children:"GG18"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"GG18: Refers to the protocol by Gennaro and Goldfeder (2018), enabling multiple parties to jointly generate ECDSA keys and signatures without revealing their private shares.\nIt supports ( t+1 ) out of ( n ) signing, meaning any subset of ( t+1 ) parties can sign."}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"gg20",children:"GG20"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"GG20: Refers to the improved protocol by Gennaro and Goldfeder (2020).\nIt adds robustness by identifying malicious parties if signing fails and requires only a broadcast channel for communication."}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"cggmp24",children:"CGGMP24"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"CGGMP24 is a state-of-art ECDSA TSS protocol that supports 1-round signing (requires 3 preprocessing rounds), identifiable abort, and a key refresh protocol."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"scopes",children:"Scopes"}),"\n",(0,t.jsx)(s.p,{children:"A complete MPC-based crypto asset custody system in Rust should cover:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Key Generation (MPC Keygen): Distributed ECDSA key generation using a GG20 protocol."}),"\n",(0,t.jsx)(s.li,{children:"Secure Storage: Each party stores its secret share securely (e.g., encrypted local file, HSM)."}),"\n",(0,t.jsx)(s.li,{children:"Signing (MPC Sign): Distributed signing protocol, requiring threshold parties to cooperate."}),"\n",(0,t.jsx)(s.li,{children:"Communication: Secure, authenticated, and encrypted messaging (over NATS)."}),"\n",(0,t.jsx)(s.li,{children:"Access Control: Party authentication, authorization, and audit logging."}),"\n",(0,t.jsx)(s.li,{children:"Recovery & Rotation: Key share recovery, rotation, and party join/leave handling."}),"\n",(0,t.jsx)(s.li,{children:"Transaction Policy: Rules for transaction approval (e.g., multi-party approval, limits)."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"mpc---ssd",children:"MPC - SSD"}),"\n",(0,t.jsx)(s.p,{children:"Professional, end-to-end design for a threshold/MPC-based crypto custody system written in Rust. I\u2019ll give: protocol choices & rationale, system architecture, required crates, concrete Rust module layout, message formats (NATS), storage/HSM choices, signing & keygen flows, recovery/rotation, transaction policy, testing & deployment notes, and short example code snippets you can drop into a Rust project."}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:["Short summary of recommended approach: implement a modern threshold-ECDSA stack (prefer CGGMP24 / audited implementations where possible) built on a tokio async runtime, using ",(0,t.jsx)(s.code,{children:"async-nats"})," for messaging, ",(0,t.jsx)(s.code,{children:"k256"})," (or vetted bindings) for curve primitives where needed, and integrate HSM/PKCS#11 or encrypted local storage for secret-share persistence. Use threshold libraries (existing Rust crates) rather than inventing low-level zero-knowledge subprotocols from scratch unless you have cryptographers on staff. Sources: DFNS CGGMP24 release, ZenGo-X multi-party ECDSA, Axelar/tofn notes, Boltlabs tss-ecdsa and Rust crypto crates. (",(0,t.jsx)(s.a,{href:"https://www.dfns.co/article/cggmp21-in-rust-at-last?utm_source=chatgpt.com",title:"CGGMP21 In Rust, At Last",children:"dfns.co"}),", ",(0,t.jsx)(s.a,{href:"https://github.com/ZenGo-X/multi-party-ecdsa?utm_source=chatgpt.com",title:"ZenGo-X/multi-party-ecdsa: Rust implementation of {t,n}",children:"GitHub"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"1-protocol-choice--justification",children:"1. Protocol choice & justification"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Primary recommendation"}),": ",(0,t.jsx)(s.strong,{children:"CGGMP24"})," (modern threshold ECDSA improvements built on/after CGGMP/CGGMP24 family) \u2014 more recent protocol addressing identified attacks on older GG20 variants; DFNS published a reviewed Rust implementation and used it in production. Use this where production-readiness and audits are required. (",(0,t.jsx)(s.a,{href:"https://www.dfns.co/article/cggmp21-in-rust-at-last?utm_source=chatgpt.com",title:"CGGMP21 In Rust, At Last",children:"dfns.co"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Alternative"}),": ",(0,t.jsx)(s.strong,{children:"GG20"})," implementation (e.g., ZenGo-X / ",(0,t.jsx)(s.code,{children:"multi-party-ecdsa"})," or ",(0,t.jsx)(s.code,{children:"tofn"}),"), acceptable but be aware of historical attacks and implementation caveats \u2014 review/adapt to known mitigations. (",(0,t.jsx)(s.a,{href:"https://github.com/ZenGo-X/multi-party-ecdsa?utm_source=chatgpt.com",title:"ZenGo-X/multi-party-ecdsa: Rust implementation of {t,n}",children:"GitHub"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"2-high-level-architecture",children:"2. High-level architecture"}),"\n",(0,t.jsx)(s.p,{children:"Components (each as a Rust microservice or library crate):"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"MPC Node / Party Agent"})," (runs at each custodian party)"]}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Implements protocol state machine for DKG (keygen), Threshold Sign, refresh/reshare, recovery."}),"\n",(0,t.jsx)(s.li,{children:"Stores local secret share (encrypted on disk or in HSM)."}),"\n",(0,t.jsx)(s.li,{children:"Connects to messaging layer (NATS)."}),"\n",(0,t.jsx)(s.li,{children:"Exposes admin gRPC/REST for health & audit."}),"\n"]}),"\n",(0,t.jsxs)(s.ol,{start:"2",children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Orchestrator"})," (optional but recommended)"]}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Subscribes to requests (API / operator)."}),"\n",(0,t.jsx)(s.li,{children:"Initiates signing sessions, enforces transaction policy, collects approvals, starts MPC rounds."}),"\n",(0,t.jsx)(s.li,{children:"Not in possession of any secret\u2014only session coordination."}),"\n"]}),"\n",(0,t.jsxs)(s.ol,{start:"3",children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:"Transaction Policy Engine"})}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Holds policy rules: thresholds, whitelists, amount limits, time windows, approval workflows."}),"\n"]}),"\n",(0,t.jsxs)(s.ol,{start:"4",children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:"Messaging Layer"})}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"NATS"})," (async-nats client) for authenticated, encrypted pub/sub + request/reply for MPC rounds. Use NATS server(s) with TLS and account/creds authentication. (",(0,t.jsx)(s.a,{href:"https://crates.io/crates/async-nats?utm_source=chatgpt.com",title:"async-nats - crates.io: Rust Package Registry",children:"Crates.io"}),", ",(0,t.jsx)(s.a,{href:"https://docs.rs/nats/latest/nats/struct.Options.html?utm_source=chatgpt.com",title:"Options in nats - Rust",children:"Docs.rs"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(s.ol,{start:"5",children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:"Storage & Key Backup"})}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Local encrypted files (age, libsodium secretbox) or HSM / PKCS#11 for share custody & signing operations."}),"\n",(0,t.jsx)(s.li,{children:"Optionally an encrypted escrow for share backups (Shamir-share-of-share encrypted, split into backup parties)."}),"\n"]}),"\n",(0,t.jsxs)(s.ol,{start:"6",children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:"Auditing & Logging"})}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Immutable event log (append-only, e.g., Kafka or write-once store) and on-chain checkpointing if desired."}),"\n",(0,t.jsx)(s.li,{children:"All protocol steps emit auditable messages (no secrets)."}),"\n"]}),"\n",(0,t.jsxs)(s.ol,{start:"7",children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:"Admin UI / API"})}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"For operator requests, recovery flows, rotation, party join/leave."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Diagram (logical): Operator/API \u2192 Orchestrator \u2192 NATS \u2192 Party Agents \u2192 HSM/Local secure store"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"3-rust-ecosystem-and-crates-recommended",children:"3. Rust ecosystem and crates (recommended)"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"MPC / Threshold ECDSA crates:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"CGGMP24"})," / ",(0,t.jsx)(s.code,{children:"dfns"})," implementation (CGGMP24) \u2014 recommended if production-ready in your review. (",(0,t.jsx)(s.a,{href:"https://crates.io/crates/CGGMP24?utm_source=chatgpt.com",title:"CGGMP24 - crates.io: Rust Package Registry",children:"Crates.io"}),", ",(0,t.jsx)(s.a,{href:"https://www.dfns.co/article/cggmp21-in-rust-at-last?utm_source=chatgpt.com",title:"CGGMP21 In Rust, At Last",children:"dfns.co"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"multi-party-ecdsa"})," (ZenGo-X). (",(0,t.jsx)(s.a,{href:"https://github.com/ZenGo-X/multi-party-ecdsa?utm_source=chatgpt.com",title:"ZenGo-X/multi-party-ecdsa: Rust implementation of {t,n}",children:"GitHub"}),")"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Curve / crypto primitives:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"k256"})," (pure-Rust secp256k1) or curated FFI to ",(0,t.jsx)(s.code,{children:"libsecp256k1"})," depending on performance/security needs. (",(0,t.jsx)(s.a,{href:"https://docs.rs/k256?utm_source=chatgpt.com",title:"k256 - Rust",children:"Docs.rs"}),", ",(0,t.jsx)(s.a,{href:"https://iqlusion.blog/k256-crate-pure-rust-projective-secp256k1-library?utm_source=chatgpt.com",title:"a pure Rust secp256k1 library based on projective formulas",children:"the iqlusion blog on Svbtle"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"rand"}),", ",(0,t.jsx)(s.code,{children:"subtle"}),", ",(0,t.jsx)(s.code,{children:"zeroize"})," for secret hygiene."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Storage & HSM:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"pkcs11"})," crates or ",(0,t.jsx)(s.code,{children:"tss-esapi"})," for TPM interfacing."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"age"})," crate for file encryption, or ",(0,t.jsx)(s.code,{children:"ring"}),"/",(0,t.jsx)(s.code,{children:"libsodium"})," bindings."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"4-detailed-module-layout-rust-workspace",children:"4. Detailed module layout (Rust workspace)"}),"\n",(0,t.jsx)(s.p,{children:"Workspace with crates:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"mpc-node/\n  Cargo.toml (workspace)\n  crates/\n    mpc-protocol/        # wraps threshold ECDSA library & protocol state machines\n    party-agent/         # binary: runs on each custodian\n    orchestrator/        # binary: orchestrates sessions, enforces policy\n    messaging/           # NATS client helpers + message schemas\n    storage/             # encrypted local storage + HSM integration\n    policy/              # transaction policy engine\n    audit/               # audit events + sink (Kafka/DB)\n    api/                 # REST/gRPC server for operators (auth)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"core-responsibilities",children:"Core responsibilities"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"mpc-protocol"}),": types ",(0,t.jsx)(s.code,{children:"KeyGenSession"}),", ",(0,t.jsx)(s.code,{children:"SignSession"}),", ",(0,t.jsx)(s.code,{children:"ReshareSession"}),". Exposes async functions that run protocol rounds and accept/send serialized protocol messages. Internally uses ",(0,t.jsx)(s.code,{children:"CGGMP24"}),"/",(0,t.jsx)(s.code,{children:"multi-party-ecdsa"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"party-agent"}),": connects to NATS, listens for protocol messages, holds ",(0,t.jsx)(s.code,{children:"LocalSecretShare"}),", signs messages produced by ",(0,t.jsx)(s.code,{children:"mpc-protocol"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"messaging"}),": contains typed NATS subjects and message envelopes with JSON/Protobuf schema, authentication tokens, and session IDs."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"storage"}),": ",(0,t.jsx)(s.code,{children:"SecretStore"})," trait with two impls: ",(0,t.jsx)(s.code,{children:"EncryptedFileStore"})," and ",(0,t.jsx)(s.code,{children:"HsmStore"})," (PKCS#11/TSS)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"policy"}),": DSL for rules, e.g., ",(0,t.jsx)(s.code,{children:"Threshold=3"}),", ",(0,t.jsx)(s.code,{children:"DailyLimit=1000 BTC"}),", ",(0,t.jsx)(s.code,{children:"RequireApprovalsFrom=[role:treasury]"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"5-messaging--session-flow-nats",children:"5. Messaging & session flow (NATS)"}),"\n",(0,t.jsx)(s.p,{children:"Design choices:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Use ",(0,t.jsx)(s.strong,{children:"per-session subjects"}),": ",(0,t.jsx)(s.code,{children:"mpc.{session_id}.party.{party_id}"})," for direct messages; ",(0,t.jsx)(s.code,{children:"mpc.{session_id}.broadcast"})," for broadcast/multiparty messages."]}),"\n",(0,t.jsx)(s.li,{children:"Messages must be signed at the transport layer using mutual TLS or NATS creds; also include MACs of message content and sequence numbers."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Example subject naming:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"mpc.keygen.{key_id}.party.{party_id}"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"mpc.sign.{tx_id}.party.{party_id}"})}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"mpc.session.{session_id}.control"})," (for control/abort)"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"All messages contain:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-protobuf",children:"message MpcEnvelope {\n  string session_id = 1;\n  uint32 round = 2;\n  bytes payload = 3; // proto of protocol-specific message\n  bytes sig = 4;     // optional transport-level signature\n  uint64 timestamp = 5;\n}\n"})}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"6-key-generation-mpc-keygen-flow-concrete",children:"6. Key generation (MPC KeyGen) flow (concrete)"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Operator"})," requests a new key (",(0,t.jsx)(s.code,{children:"orchestrator"}),")."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"orchestrator"})," creates ",(0,t.jsx)(s.code,{children:"session_id"}),", determines participants, threshold ",(0,t.jsx)(s.code,{children:"t"}),", and publishes ",(0,t.jsx)(s.code,{children:"mpc.keygen.{keyid}.start"})," with metadata."]}),"\n",(0,t.jsxs)(s.li,{children:["Each ",(0,t.jsx)(s.code,{children:"party-agent"})," loads local ",(0,t.jsx)(s.code,{children:"SecretStore"})," slot for this ",(0,t.jsx)(s.code,{children:"keyid"})," (empty for new keys)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"mpc-protocol::KeyGenSession::start(...)"})," \u2014 runs DKG rounds with messages exchanged over NATS subjects above."]}),"\n",(0,t.jsxs)(s.li,{children:["On success each ",(0,t.jsx)(s.code,{children:"party-agent"})," stores its secret share encrypted and emits an audit event ",(0,t.jsx)(s.code,{children:"KeyGenerated{key_id, public_key, party_id}"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"7-signing-mpc-sign-flow-concrete",children:"7. Signing (MPC Sign) flow (concrete)"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Submit a transaction to ",(0,t.jsx)(s.code,{children:"orchestrator"})," \u2192 orchestrator validates against ",(0,t.jsx)(s.code,{children:"policy"})," (policy engine)."]}),"\n",(0,t.jsxs)(s.li,{children:["If policy passes, orchestrator creates ",(0,t.jsx)(s.code,{children:"sign_session"})," and publishes ",(0,t.jsx)(s.code,{children:"mpc.sign.{txid}.start"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Parties receive ",(0,t.jsx)(s.code,{children:"start"}),", run ",(0,t.jsx)(s.code,{children:"mpc-protocol::SignSession::prepare(...)"})," which performs pre-sign rounds (nonce generation, commitments)."]}),"\n",(0,t.jsxs)(s.li,{children:["Exchange signing round messages over ",(0,t.jsx)(s.code,{children:"mpc.sign.{txid}.party.{id}"})," subjects. Each party verifies ZK proofs and message authenticity per protocol."]}),"\n",(0,t.jsx)(s.li,{children:"After final round, each party produces a signature share; orchestrator (or one party, depending on protocol) aggregates partial signature shares into canonical ECDSA signature."}),"\n",(0,t.jsx)(s.li,{children:"Coordinator returns signature to operator; transaction broadcast."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Security note: never reconstruct the private key; only reconstruct the signature."}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"8-storage-hsm--secure-share-handling",children:"8. Storage, HSM & secure share handling"}),"\n",(0,t.jsx)(s.p,{children:"Interfaces:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"#[async_trait]\npub trait SecretStore {\n    async fn put_share(&self, key_id: &str, share: &[u8]) -> Result<()>;\n    async fn get_share(&self, key_id: &str) -> Result<Vec<u8>>;\n    async fn delete_share(&self, key_id: &str) -> Result<()>;\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Implementations:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"EncryptedFileStore"})," \u2014 encrypt with ",(0,t.jsx)(s.code,{children:"age"})," or with an AEAD key held in local secure enclave or OS keystore."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"HsmStore"})," \u2014 uses ",(0,t.jsx)(s.code,{children:"pkcs11"})," crate or vendor SDK to store share or perform private operations inside HSM. If HSM supports only single-key ops, use it to encrypt share keys or seal ephemeral keys."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Backups:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Escrow encrypted backups split into Shamir shares stored in separate locations/parties."}),"\n",(0,t.jsx)(s.li,{children:"Recovery flow: use a quorum of recovery parties to reconstruct share."}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"9-access-control-authentication--audit",children:"9. Access Control, Authentication & Audit"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"AuthN"}),": mTLS certs or NATS creds per party. Rotate certs periodically. Use short-lived operator tokens for API access."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"AuthZ"}),": orchestrator enforces role-based rules (operator, auditor, approver)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Audit"}),": append-only ledger of protocol events (session started, rounds completed, approvals). Use Kafka or write-only DB and sign each audit record with an operational key for tamper evidence."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"10-recovery--rotation",children:"10. Recovery & Rotation"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Rotation"}),": proactive resharing (reshare protocol) without changing public key (proactive security). Use ",(0,t.jsx)(s.code,{children:"mpc-protocol::ReshareSession"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Key rotation"}),": if changing the public key is needed, run full DKG and update policies."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Party join/leave"}),": use reshare to move to new ",(0,t.jsx)(s.code,{children:"n,t"})," set. Require higher threshold for join/leave approval to avoid malicious replacement."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Loss recovery"}),": have a key escrow (encrypted shares) split among independent recovery parties; recover via threshold restore process."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"11-transaction-policy-examples",children:"11. Transaction policy examples"}),"\n",(0,t.jsx)(s.p,{children:"Policy DSL examples:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"Threshold = 3 of 5"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"DailyLimit: { coin: BTC, amount: 100.0 }"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:'RequireRoleApprovals: ["treasury_head", "compliance"]'})}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TimeLock"}),": approvals must be gathered within 24 hours else re-authorization required."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Enforce policy before starting sign session."}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"12-testing-audits--hardening",children:"12. Testing, audits & hardening"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Unit tests"})," for protocol state transitions (simulate dropped messages, replays)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Integration tests"})," with ",(0,t.jsx)(s.code,{children:"n"})," local party-agents using in-memory NATS."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Fuzzing"})," on messages and ZK-proof bytes."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Formal review"})," of cryptographic implementation by external cryptographers/security firm."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Pen tests"})," and red-team (particularly around messaging & replay attacks)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Run BFS on known vulnerabilities"})," and track crate advisories."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"13-example-code-snippets",children:"13. Example code snippets"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"Cargo.toml"})," (top-level dependencies)"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-toml",children:'[dependencies]\ntokio = { version = "1", features = ["rt-multi-thread","macros"] }\nasync-nats = "0.42"      # NATS async client\nserde = { version = "1", features = ["derive"] }\nprost = "0.11"           # if using protobufs\nk256 = "0.11"            # secp256k1 primitives\nzeroize = "1.5"\ntracing = "0.1"\nanyhow = "1.0"\n'})}),"\n",(0,t.jsx)(s.p,{children:"Minimal NATS pub/sub helper (async):"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"use async_nats::ConnectOptions;\nuse prost::Message;\nuse tokio::time::{timeout, Duration};\n\npub async fn connect_nats(endpoint:&str, creds_path: Option<&str>) -> anyhow::Result<async_nats::Client> {\n    let client = if let Some(creds) = creds_path {\n        ConnectOptions::with_credentials(creds).connect(endpoint).await?\n    } else {\n        async_nats::connect(endpoint).await?\n    };\n    Ok(client)\n}\n\npub async fn publish_envelope(client: &async_nats::Client, subject: &str, data: &[u8]) -> anyhow::Result<()> {\n    client.publish(subject.into(), data.into()).await?;\n    Ok(())\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Stub for starting a sign session in party-agent:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'async fn handle_start_sign(session_id: String, tx: Transaction) -> anyhow::Result<()> {\n    // 1) Validate operator signature & policy locally\n    // 2) Initiate sign session in mpc-protocol crate\n    let mut session = mpc_protocol::SignSession::new(session_id, tx)?;\n    loop {\n        let outgoing = session.next_message().await?;\n        // send outgoing bytes to session subject for other parties\n        publish_envelope(&client, &format!("mpc.sign.{}.broadcast", session.session_id()), &outgoing).await?;\n        if session.is_finished() { break; }\n    }\n    let signature = session.final_signature()?;\n    // return signature to orchestrator (via NATS or API)\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(s.p,{children:"(These are skeletons \u2014 real production code will wire in ZK verification, error handling, retries, timeouts, and secure memory handling.)"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"14-security-trade-offs--practical-notes",children:"14. Security trade-offs & practical notes"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Use audited crates"})," (DFNS CGGMP24, ZenGo-X, CGGMP24) \u2014 avoid rolling your own cryptography. (",(0,t.jsx)(s.a,{href:"https://www.dfns.co/article/cggmp21-in-rust-at-last?utm_source=chatgpt.com",title:"CGGMP21 In Rust, At Last",children:"dfns.co"}),", ",(0,t.jsx)(s.a,{href:"https://github.com/ZenGo-X/multi-party-ecdsa?utm_source=chatgpt.com",title:"ZenGo-X/multi-party-ecdsa: Rust implementation of {t,n}",children:"GitHub"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Performance"}),": threshold ECDSA is more expensive than single-key ECDSA; benchmark ",(0,t.jsx)(s.code,{children:"k256"})," vs libsecp FFI. (",(0,t.jsx)(s.a,{href:"https://github.com/tarcieri/rust-secp256k1-ecdsa-bench?utm_source=chatgpt.com",title:"Rust secp256k1 ECDSA benchmarks",children:"GitHub"}),", ",(0,t.jsx)(s.a,{href:"https://iqlusion.blog/k256-crate-pure-rust-projective-secp256k1-library?utm_source=chatgpt.com",title:"a pure Rust secp256k1 library based on projective formulas",children:"the iqlusion blog on Svbtle"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Attacks to watch"}),": replay attacks, message tampering, rogue-key attacks. Ensure protocol proofs and binding to session IDs."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Transport"}),": NATS is fast but requires careful setup (mTLS, creds, account limits). (",(0,t.jsx)(s.a,{href:"https://crates.io/crates/async-nats?utm_source=chatgpt.com",title:"async-nats - crates.io: Rust Package Registry",children:"Crates.io"}),", ",(0,t.jsx)(s.a,{href:"https://docs.rs/nats/latest/nats/struct.Options.html?utm_source=chatgpt.com",title:"Options in nats - Rust",children:"Docs.rs"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"15-deployment-checklist",children:"15. Deployment checklist"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Pick and vendor-lock chosen threshold crate after security review."}),"\n",(0,t.jsxs)(s.li,{children:["Build Docker images for ",(0,t.jsx)(s.code,{children:"party-agent"})," with minimal OS surface and seccomp."]}),"\n",(0,t.jsx)(s.li,{children:"Deploy NATS cluster with TLS, accounts, and monitoring."}),"\n",(0,t.jsx)(s.li,{children:"Provision HSMs or secure enclaves per party if required."}),"\n",(0,t.jsx)(s.li,{children:"Run integration testnet with simulated failures (network partition, message loss)."}),"\n",(0,t.jsx)(s.li,{children:"Schedule third-party crypto audit."}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"16-next-steps-practical-implementation-plan--6-milestones",children:"16. Next steps (practical implementation plan \u2014 6 milestones)"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Prototype"}),": wire ",(0,t.jsx)(s.code,{children:"party-agent"})," + ",(0,t.jsx)(s.code,{children:"orchestrator"})," using ",(0,t.jsx)(s.code,{children:"multi-party-ecdsa"})," or ",(0,t.jsx)(s.code,{children:"CGGMP24"})," in a local NATS test cluster. Implement EncryptedFileStore."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Integration tests"}),": 3-of-5 signing and keygen tests, simulate recovery and rotation."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Security review"}),": get a crypto audit on protocol usage and implementation."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"HSM integration"}),": implement ",(0,t.jsx)(s.code,{children:"HsmStore"})," and test key sealing/unsealing."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Policy engine & UI"}),": operator workflows and approval flows."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Production rollout"}),": harden, monitor, and staged rollout."]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"17-useful-references--starting-points",children:"17. Useful references & starting points"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["ZenGo-X ",(0,t.jsx)(s.code,{children:"multi-party-ecdsa"})," (Rust). (",(0,t.jsx)(s.a,{href:"https://github.com/ZenGo-X/multi-party-ecdsa?utm_source=chatgpt.com",title:"ZenGo-X/multi-party-ecdsa: Rust implementation of {t,n}",children:"GitHub"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:["DFNS CGGMP24 Rust implementation / write-up (production & audit note). (",(0,t.jsx)(s.a,{href:"https://www.dfns.co/article/cggmp21-in-rust-at-last?utm_source=chatgpt.com",title:"CGGMP21 In Rust, At Last",children:"dfns.co"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"async-nats"})," crate docs (NATS Rust client). (",(0,t.jsx)(s.a,{href:"https://crates.io/crates/async-nats?utm_source=chatgpt.com",title:"async-nats - crates.io: Rust Package Registry",children:"Crates.io"}),", ",(0,t.jsx)(s.a,{href:"https://docs.rs/nats?utm_source=chatgpt.com",title:"nats - Rust",children:"Docs.rs"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"k256"})," crate (secp256k1 pure-Rust). (",(0,t.jsx)(s.a,{href:"https://docs.rs/k256?utm_source=chatgpt.com",title:"k256 - Rust",children:"Docs.rs"}),", ",(0,t.jsx)(s.a,{href:"https://crates.io/crates/k256?utm_source=chatgpt.com",title:"k256 - crates.io: Rust Package Registry",children:"Crates.io"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"mpc-over-nats-architecture",children:"MPC over NATS architecture"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Run your own private NATS cluster (not public NGS) for security."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Each node:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Connects via mTLS (certs signed by your CA)."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Subscribes to a subject named after its ID (mpc.node.<id>)."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Publishes MPC messages directly to the recipient\u2019s subject."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"For group broadcasts: use a shared subject (mpc.round.<round_id>)."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Add application-level AEAD encryption (ChaCha20-Poly1305 or AES-GCM) per MPC message so that even if NATS is compromised, contents stay secret."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Example:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Node A \u2192 publishes encrypted share to mpc.node.2."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Node B \u2192 has subscription to mpc.node.2, receives it, decrypts, processes."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"For broadcast (e.g., commitments), Node A \u2192 publishes to mpc.round.5, all nodes subscribed get it."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"key-share-storage-best-practices",children:"Key Share Storage Best Practices"}),"\n",(0,t.jsx)(s.p,{children:"Example:"}),"\n",(0,t.jsx)(s.p,{children:"Party A: Stores its share inside AWS KMS/HSM, with no export permission."}),"\n",(0,t.jsx)(s.p,{children:"Party B: Stores its share in Azure HSM."}),"\n",(0,t.jsx)(s.p,{children:"Party C: Runs inside an Intel SGX enclave on-premises."}),"\n",(0,t.jsx)(s.p,{children:"Each share is encrypted at rest, protected by per-party infrastructure, and only accessible by the MPC runtime."})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);